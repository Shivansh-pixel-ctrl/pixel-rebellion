<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
<title>PIXEL REBELLION — FINAL (15 Levels)</title>
<style>
  html, body { margin:0; padding:0; background:#0b0f1a; height:100%; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; color:#e4e7ee; }
  #wrap { display:flex; flex-direction:column; height:100%; }
  header { padding:10px 12px; background:#121829; border-bottom:1px solid #1f2840; }
  header h1 { margin:0; font-size:18px; letter-spacing:1px; }
  #hud { display:flex; gap:14px; align-items:center; font-size:12px; flex-wrap:wrap; }
  #hud .tag { padding:4px 8px; border:1px solid #2a355a; border-radius:6px; }
  #canvasWrap { flex:1; display:flex; align-items:center; justify-content:center; padding:8px; }
  canvas { background:linear-gradient(#121829, #0b0f1a); border:1px solid #1f2840; border-radius:10px; width:100%; max-width:960px; aspect-ratio: 16 / 9; touch-action:none; }
  footer { padding:8px 12px; background:#0f1628; border-top:1px solid #1f2840; font-size:12px; line-height:1.4; display:flex; justify-content:space-between; gap:10px; flex-wrap:wrap;}
  kbd { background:#141c33; border:1px solid #27345b; border-radius:4px; padding:1px 4px; font-size:11px; }
</style>
</head>
<body>
<div id="wrap">
  <header>
    <h1>PIXEL REBELLION — FINAL</h1>
    <div id="hud">
      <div class="tag">Move: <kbd>A</kbd>/<kbd>D</kbd> or <kbd>◀︎</kbd>/<kbd>▶︎</kbd></div>
      <div class="tag">Jump: <kbd>W</kbd> / <kbd>Space</kbd> / <kbd>▲</kbd></div>
      <div class="tag">Hack: <kbd>1</kbd> Phase, <kbd>2</kbd> Trampoline, <kbd>3</kbd> Slow</div>
      <div class="tag">Apply Hack: Mouse/Tap near you</div>
      <div class="tag">Reset: <kbd>R</kbd></div>
    </div>
  </header>
  <div id="canvasWrap">
    <canvas id="game" width="960" height="540"></canvas>
  </div>
  <footer>
    <div>Reach the neon gate to advance. Levels get harder (more/faster red patrols).</div>
    <div>Level: <span id="levelNum">1</span> / <span id="levelMax">15</span></div>
  </footer>
</div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const levelNumEl = document.getElementById('levelNum');
  const levelMaxEl = document.getElementById('levelMax');

  // ---------- Constants ----------
  const TILE = 30;
  const GRAVITY = 0.55;
  const JUMP_V = -12;
  const MOVE_SPEED = 4.0;
  const AIR_DRAG = 0.86;
  const MAX_HACK_RANGE = 6;
  const PLAYER_W = 22, PLAYER_H = 26;

  // Tile types
  const T_EMPTY = 0, T_SOLID = 1, T_PHASE = 2, T_TRAMP = 3, T_SLOW = 4;

  // Colors
  const C_SOLID = '#1b2442';
  const C_GRID = 'rgba(255,255,255,0.03)';
  const C_PLAYER_ACCENT = '#00ffd5';
  const C_PHASE = 'rgba(0,255,255,0.20)';
  const C_TRAMP = 'rgba(255, 102, 153, 0.25)';
  const C_SLOW  = 'rgba(255, 255, 0, 0.20)';
  const C_GATE = '#63ff8b';
  const C_ENEMY = '#ff4b4b';
  const C_TEXT = '#e4e7ee';

  // ---------- Base Levels 1–6 (handcrafted) ----------
  const lvl1 = {
    map: [
      "................................#..",
      ".............................##....",
      ".........................##........",
      "......................##...........",
      "...................##..............",
      "................##.................",
      ".............##....................",
      "..........##........................",
      ".......##.............###..........",
      "....##..................#..........",
      "..##................................",
      "##.........................###......",
      "##.............####................#",
      "###...............................##",
      "####....................###.......##",
      "#####..............###............##",
      "######........################..####",
      "####################################"
    ],
    playerStart: { c: 2, r: 4 },
    goal:        { c: 33, r: 10, w: 1, h: 4 },
    enemies: [
      { type:'patrol', w:16, h:16, r: ROWS=>ROWS-5, cStart: 15, xMin: 12, xMax: 20, speed: 1.2 }
    ]
  };

  const lvl2 = {
    map: [
      "....................................",
      "...........................##.......",
      ".......................##...........",
      "...................##...............",
      ".................##.................",
      "..............##....................",
      "..........##........................",
      ".......##..................###......",
      "....##.......................#......",
      "..##..........................#.....",
      "##............................#.....",
      "##.................####............#",
      "###...............................##",
      "####....................###.......##",
      "#####..............###............##",
      "######......##..##############..####",
      "######......##..................####",
      "####################################"
    ],
    playerStart: { c: 2, r: 3 },
    goal:        { c: 34, r: 9, w: 1, h: 4 },
    enemies: [
      { type:'patrol', w:16, h:16, r: ROWS=>ROWS-6,  cStart: 12, xMin: 10, xMax: 22, speed: 1.5 },
      { type:'patrol', w:16, h:16, r: ROWS=>ROWS-9,  cStart: 20, xMin: 18, xMax: 30, speed: 1.6 },
      { type:'patrol', w:16, h:16, r: ROWS=>ROWS-12, cStart: 26, xMin: 24, xMax: 33, speed: 1.4 }
    ]
  };

  const lvl3 = {
    map: [
      "....................................",
      "........................####........",
      "....................####............",
      ".................###................",
      "..............###...................",
      "...........###......................",
      "........###...........###...........",
      ".....###.................###........",
      "...###......................###.....",
      "###.........................###.....",
      "##..............####........###.....",
      "##...........########........#......",
      "###..............####........#......",
      "####........................##......",
      "#####....................######.....",
      "######.........##..#############....",
      "######.........##.................##",
      "####################################"
    ],
    playerStart: { c: 2, r: 2 },
    goal:        { c: 34, r: 8, w: 1, h: 4 },
    enemies: [
      { type:'patrol', w:16, h:16, r: ROWS=>ROWS-6,  cStart: 12, xMin: 9,  xMax: 22, speed: 1.8 },
      { type:'patrol', w:16, h:16, r: ROWS=>ROWS-10, cStart: 20, xMin: 18, xMax: 31, speed: 1.9 },
      { type:'patrol', w:16, h:16, r: ROWS=>ROWS-13, cStart: 25, xMin: 22, xMax: 34, speed: 2.0 },
      { type:'patrol', w:16, h:16, r: ROWS=>ROWS-15, cStart: 30, xMin: 27, xMax: 36, speed: 2.1 }
    ]
  };

  const lvl4 = {
    map: [
      "........................................",
      "..........................###...........",
      "......................###...............",
      "..................###...................",
      ".............###........................",
      ".........###............................",
      ".....###....................####........",
      "..###.........................#.........",
      "###...........................#.........",
      "##.......................###..#.........",
      "##......................####..#.........",
      "###...................######..#.........",
      "####..............###.........##........",
      "#####..........###............##........",
      "######......###...........#########.....",
      "#######..##########..################...",
      "#######..##########..################...",
      "########################################"
    ],
    playerStart: { c: 2, r: 3 },
    goal:        { c: 38, r: 9, w: 1, h: 4 },
    enemies: [
      { type:'patrol', w:16, h:16, r: ROWS=>ROWS-6,  cStart: 12, xMin: 8,  xMax: 20, speed: 2.0 },
      { type:'patrol', w:16, h:16, r: ROWS=>ROWS-9,  cStart: 20, xMin: 16, xMax: 30, speed: 2.1 },
      { type:'patrol', w:16, h:16, r: ROWS=>ROWS-12, cStart: 26, xMin: 24, xMax: 36, speed: 2.2 },
      { type:'patrol', w:16, h:16, r: ROWS=>ROWS-14, cStart: 32, xMin: 30, xMax: 40, speed: 2.3 }
    ]
  };

  const lvl5 = {
    map: [
      "........................................",
      "....................####...............#",
      ".................####..................#",
      "..............####.....................#",
      "..........####.........................#",
      ".......####............................#",
      "....####.......................###.....#",
      "..###.........................####.....#",
      "###.......................########.....#",
      "##....................############.....#",
      "##.............###.....................#",
      "###..........#####.....................#",
      "####......########.....................#",
      "#####..#############...................#",
      "######.###############.................#",
      "#############################......#####",
      "#############################......#####",
      "########################################"
    ],
    playerStart: { c: 2, r: 2 },
    goal:        { c: 38, r: 8, w: 1, h: 4 },
    enemies: [
      { type:'patrol', w:16, h:16, r: ROWS=>ROWS-7,  cStart: 10, xMin: 6,  xMax: 22, speed: 2.4 },
      { type:'patrol', w:16, h:16, r: ROWS=>ROWS-9,  cStart: 18, xMin: 16, xMax: 30, speed: 2.6 },
      { type:'patrol', w:16, h:16, r: ROWS=>ROWS-11, cStart: 26, xMin: 24, xMax: 36, speed: 2.8 },
      { type:'patrol', w:16, h:16, r: ROWS=>ROWS-13, cStart: 32, xMin: 28, xMax: 40, speed: 3.0 }
    ]
  };

  const lvl6 = {
    map: [
      "........................................",
      ".....................###...............#",
      "..................####.................#",
      "...............####....................#",
      "............####.......................#",
      ".........####..........................#",
      "......####..................####.......#",
      "....###.....................#####......#",
      "..###......................######......#",
      "###.....................#########......#",
      "##...................#############.....#",
      "##..............###################....#",
      "###.........########################...#",
      "####....#############################..#",
      "######################################.#",
      "########################################",
      "########################################",
      "########################################"
    ],
    playerStart: { c: 2, r: 2 },
    goal:        { c: 38, r: 7, w: 1, h: 4 },
    enemies: [
      { type:'patrol', w:16, h:16, r: ROWS=>ROWS-8,  cStart: 12, xMin: 8,  xMax: 22, speed: 3.0 },
      { type:'patrol', w:16, h:16, r: ROWS=>ROWS-10, cStart: 20, xMin: 18, xMax: 30, speed: 3.2 },
      { type:'patrol', w:16, h:16, r: ROWS=>ROWS-12, cStart: 28, xMin: 26, xMax: 38, speed: 3.4 },
      { type:'patrol', w:16, h:16, r: ROWS=>ROWS-14, cStart: 34, xMin: 32, xMax: 40, speed: 3.6 }
    ]
  };

  // Helper to generate step-like maps for levels 7–15
  function genStepMap(cols, rows, stepSpan, steepness){
    const grid = Array.from({length: rows}, () => Array.from({length: cols}, () => '.'));
    for (let c=0;c<cols;c++) grid[rows-1][c] = '#';
    let r = rows-3;
    for (let c=0;c<cols-1;c++){
      if (c % stepSpan === 0 && r>2){ r -= steepness; }
      r = Math.max(2, Math.min(rows-2, r));
      grid[r][c] = '#';
      if (Math.random()<0.25 && r+1<rows-1) grid[r+1][c] = '#';
      if (Math.random()<0.2 && c+1<cols) grid[r][c+1] = '#';
    }
    for (let i=0;i<Math.floor(cols/6);i++){
      const rr = 2 + Math.floor(Math.random()*(rows-6));
      const cc = 4 + Math.floor(Math.random()*(cols-8));
      for (let k=0;k<3;k++){ grid[rr][cc+k] = '#'; }
    }
    return grid.map(row => row.join(''));
  }

  function makeProceduralLevel(index){
    const cols = 40 + Math.floor((index-7) * 2);
    const rows = 18;
    const stepSpan = Math.max(3, 6 - Math.floor((index-7)/2));
    const steepness = (index<10) ? 1 : 1 + Math.floor((index-10)/3);
    const map = genStepMap(cols, rows, stepSpan, steepness);
    const goalC = cols - 4;
    const goalR = Math.max(6, Math.floor(rows/2));
    const enemyCount = Math.min(6, 2 + Math.floor((index-7)/1));
    const speedBase = 2.0 + 0.2*(index-7);
    const enemies = [];
    for (let i=0;i<enemyCount;i++){
      const laneRow = rows - (5 + i*2);
      const xMin = 6 + i*3;
      const xMax = Math.min(cols-2, xMin + 12 + i*3);
      enemies.push({
        type:'patrol', w:16, h:16,
        r: ROWS=>laneRow, cStart: xMin + 2,
        xMin, xMax, speed: speedBase + 0.15*i
      });
    }
    return {
      map,
      playerStart: { c: 2, r: rows-6 },
      goal: { c: goalC, r: goalR, w: 1, h: 4 },
      enemies
    };
  }

  const LEVELS = [lvl1, lvl2, lvl3, lvl4, lvl5, lvl6];
  for (let i=7;i<=15;i++) LEVELS.push(makeProceduralLevel(i));
  levelMaxEl.textContent = LEVELS.length.toString();

  // ---------- Runtime state ----------
  let ROWS=0, COLS=0, level=[], levelText=[], goal, enemies=[], player, inputs, camera, hackMode, levelIndex=0;

  function loadLevel(i){
    levelIndex = i % LEVELS.length;
    const L = LEVELS[levelIndex];
    levelText = L.map;
    ROWS = levelText.length;
    COLS = levelText[0].length;
    level = Array.from({length: ROWS}, (_, r) =>
      Array.from({length: COLS}, (_, c) => levelText[r][c] === '#' ? T_SOLID : T_EMPTY)
    );
    goal = { ...L.goal };
    enemies = L.enemies.map(e => {
      const rowIdx = (typeof e.r === 'function') ? e.r(ROWS) : e.r;
      const y = rowIdx*TILE - e.h;
      const x = e.cStart*TILE;
      return { type:e.type, x, y, w:e.w, h:e.h, dir: 1, speed:e.speed, xMin:e.xMin*TILE, xMax:e.xMax*TILE };
    });
    const ps = L.playerStart;
    player = { x: ps.c*TILE, y: ps.r*TILE, vx:0, vy:0, onGround:false, energy:100 };
    inputs = { left:false, right:false, up:false, jumpPressed:false };
    camera = { x:0, y:0 };
    hackMode = 1;
    levelNumEl.textContent = (levelIndex+1).toString();
  }

  loadLevel(0);

  // ---------- Input ----------
  const KEYS = { 37:'left',65:'left', 39:'right',68:'right', 38:'up',87:'up',32:'up', 49:'hack1',50:'hack2',51:'hack3', 82:'reset' };
  document.addEventListener('keydown', (e) => {
    const act = KEYS[e.keyCode];
    if (!act) return;
    if (act === 'left') inputs.left = true;
    if (act === 'right') inputs.right = true;
    if (act === 'up') { inputs.up = true; inputs.jumpPressed = true; }
    if (act === 'hack1') hackMode = 1;
    if (act === 'hack2') hackMode = 2;
    if (act === 'hack3') hackMode = 3;
    if (act === 'reset') loadLevel(levelIndex);
  });
  document.addEventListener('keyup', (e) => {
    const act = KEYS[e.keyCode];
    if (!act) return;
    if (act === 'left') inputs.left = false;
    if (act === 'right') inputs.right = false;
    if (act === 'up') inputs.up = false;
  });

  // Apply hack by clicking/tapping a tile within range
  canvas.addEventListener('pointerdown', (e) => {
    const rect = canvas.getBoundingClientRect();
    const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
    const my = (e.clientY - rect.top) * (canvas.height / rect.height);
    const worldX = camera.x + mx;
    const worldY = camera.y + my;
    const tc = Math.floor(worldX / TILE);
    const tr = Math.floor(worldY / TILE);
    const pc = Math.floor(player.x / TILE);
    const pr = Math.floor(player.y / TILE);
    const dist = Math.hypot(tc - pc, tr - pr);
    if (dist <= MAX_HACK_RANGE && inBounds(tr, tc) && player.energy >= 5) {
      const current = level[tr][tc];
      if (hackMode === 1) level[tr][tc] = (current === T_PHASE) ? (hasSupport(tr, tc) ? T_SOLID : T_EMPTY) : T_PHASE;
      if (hackMode === 2) level[tr][tc] = (current === T_TRAMP) ? (hasSupport(tr, tc) ? T_SOLID : T_EMPTY) : T_TRAMP;
      if (hackMode === 3) level[tr][tc] = (current === T_SLOW)  ? (hasSupport(tr, tc) ? T_SOLID : T_EMPTY) : T_SLOW;
      player.energy = Math.max(0, player.energy - 5);
    }
  });

  function inBounds(r,c){ return r>=0 && r<ROWS && c>=0 && c<COLS; }
  function hasSupport(r,c) { return levelText[r][c] === '#'; }

  // ---------- Physics & Collision ----------
  function rectVsTiles(x, y, w, h, vx, vy) {
    let nx = x + vx, ny = y + vy;
    let onGround = false;
    if (vx !== 0) {
      const dir = Math.sign(vx);
      const ahead = Math.floor((nx + (dir>0 ? w : 0)) / TILE);
      const top = Math.floor(ny / TILE);
      const bottom = Math.floor((ny + h - 1) / TILE);
      for (let r = top; r <= bottom; r++) {
        if (!inBounds(r, ahead)) continue;
        const t = level[r][ahead];
        if (t === T_SOLID || t === T_TRAMP) {
          nx = ahead * TILE - (dir>0 ? w : -TILE);
          vx = 0;
          break;
        }
      }
    }
    if (vy !== 0) {
      const dir = Math.sign(vy);
      const below = Math.floor((ny + (dir>0 ? h : 0)) / TILE);
      const left = Math.floor(nx / TILE);
      const right = Math.floor((nx + w - 1) / TILE);
      for (let c = left; c <= right; c++) {
        if (!inBounds(below, c)) continue;
        const t = level[below][c];
        if (t === T_SOLID || t === T_TRAMP) {
          if (dir > 0) onGround = true;
          ny = below * TILE - (dir>0 ? h : -TILE);
          if (t === T_TRAMP && dir > 0 && Math.abs(vy) > 1) {
            vy = JUMP_V * 1.15;
          } else {
            vy = 0;
          }
          break;
        }
      }
    }
    return { x:nx, y:ny, vx, vy, onGround };
  }

  function updateEnemies(dt) {
    for (const en of enemies) {
      if (en.type === 'patrol') {
        en.x += en.speed * en.dir;
        if (en.x <= en.xMin*TILE) { en.x = en.xMin*TILE; en.dir = 1; }
        if (en.x + en.w >= en.xMax*TILE) { en.x = en.xMax*TILE - en.w; en.dir = -1; }
      }
    }
  }

  // ---------- Game Loop ----------
  let last = 0;
  function loop(ts) {
    const dt = Math.min(32, ts - last);
    last = ts;

    let targetVX = 0;
    if (inputs.left) targetVX -= MOVE_SPEED;
    if (inputs.right) targetVX += MOVE_SPEED;
    player.vx = targetVX;

    if (inputs.jumpPressed && player.onGround) {
      player.vy = JUMP_V;
    }
    inputs.jumpPressed = false;

    player.vy += GRAVITY;
    if (!inputs.left && !inputs.right) player.vx *= AIR_DRAG;

    const res = rectVsTiles(player.x, player.y, PLAYER_W, PLAYER_H, player.vx, player.vy);
    Object.assign(player, res);

    player.energy = Math.min(100, player.energy + 0.035 * dt);

    updateEnemies(dt);

    for (const en of enemies) {
      if (aabb(player.x, player.y, PLAYER_W, PLAYER_H, en.x, en.y, en.w, en.h)) {
        loadLevel(levelIndex);
        break;
      }
    }

    if (aabb(player.x, player.y, PLAYER_W, PLAYER_H, goal.c*TILE, goal.r*TILE, goal.w*TILE, goal.h*TILE)) {
      if (levelIndex < LEVELS.length - 1) {
        loadLevel(levelIndex + 1);
      } else {
        alert("GG! You cleared all 15 levels. Restarting at Level 1.");
        loadLevel(0);
      }
    }

    const worldW = COLS*TILE, worldH = ROWS*TILE;
    const camTargetX = player.x - canvas.width/2 + PLAYER_W/2;
    const camTargetY = player.y - canvas.height/2 + PLAYER_H/2;
    camera.x = clamp(camTargetX, 0, Math.max(0, worldW - canvas.width));
    camera.y = clamp(camTargetY, 0, Math.max(0, worldH - canvas.height));

    draw();

    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // ---------- Rendering ----------
  function draw() {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.save();
    ctx.translate(-camera.x*0.2, -camera.y*0.2);
    drawGrid();
    ctx.restore();
    ctx.save();
    ctx.translate(-camera.x, -camera.y);

    for (let r=0; r<ROWS; r++) {
      for (let c=0; c<COLS; c++) {
        const x = c*TILE, y = r*TILE;
        const t = level[r][c];
        if (t === T_SOLID) {
          ctx.fillStyle = C_SOLID; ctx.fillRect(x,y,TILE,TILE);
        } else if (t === T_PHASE) {
          ctx.fillStyle = C_PHASE; ctx.fillRect(x,y,TILE,TILE);
          neonRect(x, y, TILE, TILE, '#00e5ff', 0.45);
        } else if (t === T_TRAMP) {
          ctx.fillStyle = C_TRAMP; ctx.fillRect(x,y,TILE,TILE);
          neonRect(x, y, TILE, TILE, '#ff5599', 0.45);
        } else if (t === T_SLOW) {
          ctx.fillStyle = C_SLOW; ctx.fillRect(x,y,TILE,TILE);
          neonRect(x, y, TILE, TILE, '#ffee00', 0.45);
        }
      }
    }

    drawGate(goal.c*TILE, goal.r*TILE, goal.w*TILE, goal.h*TILE);

    for (const en of enemies) {
      neonRect(en.x, en.y, en.w, en.h, C_ENEMY, 0.9);
      ctx.fillStyle = 'rgba(255,75,75,0.18)';
      ctx.fillRect(en.x, en.y, en.w, en.h);
    }

    neonRect(player.x, player.y, PLAYER_W, PLAYER_H, C_PLAYER_ACCENT, 0.9);
    ctx.fillStyle = 'rgba(127,255,212,0.15)';
    ctx.fillRect(player.x, player.y, PLAYER_W, PLAYER_H);

    ctx.fillStyle = C_TEXT;
    ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillText(`Energy: ${player.energy.toFixed(0)}%`, camera.x + 10, camera.y + 16);
    const modes = ['Phase (1)', 'Trampoline (2)', 'Slow (3)'];
    ctx.fillText(`Hack: ${modes[hackMode-1]}`, camera.x + 10, camera.y + 32);

    ctx.restore();
  }

  function drawGrid() {
    const step = TILE;
    ctx.strokeStyle = C_GRID;
    ctx.lineWidth = 1;
    for (let x= (-camera.x%step); x<canvas.width+step; x+=step) {
      ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); ctx.stroke();
    }
    for (let y= (-camera.y%step); y<canvas.height+step; y+=step) {
      ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); ctx.stroke();
    }
  }

  function neonRect(x,y,w,h,color,alpha=0.8){
    ctx.save();
    ctx.shadowColor = color;
    ctx.shadowBlur = 16;
    ctx.globalAlpha = alpha;
    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.strokeRect(x+1,y+1,w-2,h-2);
    ctx.restore();
  }

  function drawGate(x,y,w,h){
    neonRect(x,y,w,h,C_GATE,0.9);
    for (let i=0;i<h;i+=6){
      ctx.fillStyle = 'rgba(99,255,139,0.15)';
      ctx.fillRect(x+4, y+i+2, w-8, 2);
    }
  }

  function aabb(x1,y1,w1,h1,x2,y2,w2,h2){
    return x1 < x2 + w2 && x1 + w1 > x2 && y1 < y2 + h2 && y1 + h1 > y2;
  }
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

  function inBounds(r,c){ return r>=0 && r<ROWS && c>=0 && c<COLS; }
  function hasSupport(r,c) { return levelText[r][c] === '#'; }
})();
</script>
</body>
</html>
